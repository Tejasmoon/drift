<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drift for Flutter Cheatsheet</title>
    <!-- Google Fonts: Inter for body, JetBrains Mono for code -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- Prism.js for syntax highlighting (Default Light Theme) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            /* Default Light Theme Palette */
            --bg-color: #ffffff;
            --surface-color: #f8f9fa;
            --border-color: #dee2e6;
            --text-color: #212529;
            
            --header-color: #0056b3;
            --accent-color: #6f42c1;
            
            --button-bg: #6c757d;
            --button-hover-bg: #5a6268;
            --button-copied-bg: #28a745;
            
            --navbar-height: 60px;
        }

        html {
            scroll-behavior: smooth;
            scroll-padding-top: calc(var(--navbar-height) + 1rem);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.7;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding-top: var(--navbar-height);
        }
        
        /* === Sticky Navbar === */
        .navbar {
            position: fixed; top: 0; left: 0; width: 100%; height: var(--navbar-height);
            background-color: var(--surface-color); border-bottom: 1px solid var(--border-color);
            z-index: 1000; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .navbar ul { display: flex; list-style: none; margin: 0; padding: 0 1rem; overflow-x: auto; }
        .navbar li a {
            display: block; padding: 0 1rem; line-height: var(--navbar-height); text-decoration: none;
            color: var(--header-color); font-weight: 700; white-space: nowrap;
            transition: background-color 0.2s, color 0.2s; border-bottom: 2px solid transparent;
        }
        .navbar li a:hover { background-color: #e9ecef; color: #000; }
        
        /* === Main Content === */
        .container { max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
        h1, h2, h3, h4, h5 { font-weight: 700; }
        h1 { text-align: center; font-size: 2.5em; border-bottom: none; }
        h2 { margin-top: 3em; font-size: 2em; color: var(--header-color); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        h3 { margin-top: 2.5em; font-size: 1.5em; color: #007bff; border-bottom-style: dashed; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        h4 { margin-top: 2em; font-size: 1.3em; color: var(--accent-color); border-bottom: 1px solid #e9ecef; padding-bottom: 5px; }
        h5 { margin-top: 1em; font-size: 1.1em; font-weight: 700; color: var(--text-color); }
        
        p, li { font-size: 1.1em; }
        
        /* === Professional Code Styling === */
        pre, code, pre *, code * {
            font-family: 'JetBrains Mono', monospace !important;
            font-variant-ligatures: none;
        }
        
        pre {
            border: 1px solid var(--border-color); border-radius: 8px;
            padding: 1.2em; overflow-x: auto; position: relative;
            line-height: 1.6; font-size: 0.9em;
            margin: 1em 0;
        }
        
        code:not(pre > code) {
            background-color: #e9ecef; color: #c7254e;
            padding: 0.2em 0.4em; border-radius: 4px; font-size: 0.85em;
        }
        
        .copy-button {
            position: absolute; top: 10px; right: 10px; background-color: var(--button-bg);
            color: #ffffff; border: none; padding: 8px 12px;
            border-radius: 5px; cursor: pointer; opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s; font-family: 'Inter', sans-serif;
        }
        
        pre:hover .copy-button { opacity: 1; }
        .copy-button:hover { background-color: var(--button-hover-bg); }
        .copy-button.copied { background-color: var(--button-copied-bg); }
        
        .note {
            background-color: #fff3cd; border-left: 4px solid #ffeeba;
            color: #664d03; padding: 1em; border-radius: 8px; margin: 1.5em 0;
        }

        /* === FIX for PrismJS Background Glitch === */
        .token.operator, .token.entity, .token.url,
        .language-css .token.string, .style .token.string {
            background: transparent;
        }
    </style>
  
</head>
<body>
    <nav class="navbar">
        <ul>
            <li><a href="#setup">Setup</a></li>
            <li><a href="#tables">Tables</a></li>
            <li><a href="#crud">CRUD</a></li>
            <li><a href="#streams">Streams</a></li>
            <li><a href="#filtering">Filtering</a></li>
            <li><a href="#aggregation">Aggregation</a></li>
            <li><a href="#advanced">Advanced</a></li>
            <li><a href="#migrations">Migrations</a></li>
            <li><a href="#best-practices">Best Practices</a></li>
        </ul>
    </nav>
    <div class="container">
        <h1>Drift for Flutter Cheatsheet</h1>
        <p>A comprehensive, single-file guide to Drift, the reactive persistence library for Dart & Flutter.</p>

        <h2 id="setup">1. Setup</h2>
        <p>Add the following dependencies to your <code>pubspec.yaml</code> file. The <code>drift_dev</code> and <code>build_runner</code> packages are for code generation, which is a core part of Drift.</p>
        <pre><button class="copy-button">Copy</button><code class="language-yaml">
dependencies:
  flutter:
    sdk: flutter
  drift: ^2.18.0
  sqlite3_flutter_libs: ^0.5.20
  path_provider: ^2.1.3
  path: ^1.9.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  drift_dev: ^2.18.0
  build_runner: ^2.4.9
</code></pre>

        <h2 id="tables">2. Defining Tables & Code Generation</h2>
        <p>
            Tables are defined as Dart classes that extend <code>Table</code>. You define columns as getters, and each column type has its own set of modifiers (e.g., <code>.autoIncrement()</code>, <code>.withLength()</code>, <code>.withDefault()</code>).
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
import 'package:drift/drift.dart';

// Represents a category for todos
@TableIndex(name: 'idx_category_name', columns: {#name})
class Categories extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().withLength(min: 3, max: 32).unique()();
  // We use .unique() here to ensure no two categories have the same name.
}

// Represents a user who creates todos
class Users extends Table {
  TextColumn get id => text()(); // Use a string ID for a user
  TextColumn get name => text().withLength(min: 3, max: 50)();

  @override
  Set&lt;Column&gt; get primaryKey => {id}; // Define a custom primary key
}

// A Dart enum for priority levels
enum Priority { low, medium, high }

class Todos extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get title => text().withLength(min: 6, max: 50)();
  TextColumn get content => text().named('body')();
  BoolColumn get completed => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  
  // A column that must be unique, not including the primary key
  TextColumn get uuid => text().unique()();
  
  // A nullable foreign key referencing the `Categories` table
  IntColumn get categoryId => integer().nullable().references(Categories, #id)();

  // A foreign key for the User who owns this todo
  TextColumn get userId => text().references(Users, #id)();
  
  // A custom column that will be stored as an integer, but handled as a Dart enum
  IntColumn get priority => intEnum&lt;Priority&gt;().withDefault(const Constant(0))();
}
</code></pre>
        <p>After defining your tables, run the code generator to create the necessary boilerplate:</p>
        <pre><button class="copy-button">Copy</button><code class="language-bash">
dart run build_runner build --delete-conflicting-outputs
</code></pre>

        <h3>Foreign Keys</h3>
        <p>
            Foreign keys are essential for defining <b>relationships</b> between tables and ensuring <b>data integrity</b>. They prevent you from having an item that references a non-existent entry in another table. Drift makes them type-safe and easy to use with the <code>.references()</code> syntax.
        </p>
        
        <h4>Basic Reference: <code>references()</code></h4>
        <p>
            This is the most common use case. The <code>todos</code> table has a <code>categoryId</code> column that references the <code>id</code> column of the <code>categories</code> table. Drift ensures you cannot insert a todo with a category ID that doesn't exist.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// `Todos` table referencing `Categories`
class Todos extends Table {
  // ... other columns
  // A nullable foreign key pointing to the `Categories` table
  IntColumn get categoryId => integer().nullable().references(Categories, #id)();
}
</code></pre>
        <p>
            Here, the <code>#id</code> syntax is a Dart symbol that references the <code>id</code> column on the <code>Categories</code> table, which is a powerful way to ensure type safety. Drift will automatically generate a <code>categoryId</code> column.
        </p>

        <h4>On Delete Action: <code>onDelete</code></h4>
        <p>
            Foreign keys can also define what happens when a referenced row is deleted. This is crucial for maintaining a clean and consistent database. The two most common actions are <code>cascade</code> and <code>setNull</code>.
        </p>
        
        <p><b>KeyAction.cascade</b> (Delete the children)</p>
        <p>
            This is the most destructive action. When you delete a row from the parent table, <b>all rows in the child table that reference it will also be deleted automatically</b>. This is useful for strong, hierarchical relationships, like an album and its photos.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A `Photos` table that is strongly linked to an `Albums` table
class Albums extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
}

class Photos extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get url => text()();
  // If an album is deleted, all photos in that album will also be deleted.
  IntColumn get albumId => integer().references(Albums, #id, onDelete: KeyAction.cascade)();
}

// In your DAO, if you were to delete an album:
// await (db.delete(db.albums)..where((a) => a.id.equals(1))).go();
// This will automatically delete all photos where `albumId` is 1.
</code></pre>

        <p><b>KeyAction.setNull</b> (Unlink the children)</p>
        <p>
            This action is less destructive. When you delete a parent row, the foreign key column in all child rows that reference it is simply <b>set to <code>null</code></b>. This is perfect for the <code>todos</code> and <code>categories</code> relationship, where a todo can exist without a category.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A `Todos` table referencing `Categories` with `setNull`
class Todos extends Table {
  // ... other columns
  // When a category is deleted, the `categoryId` on its todos is set to null.
  IntColumn get categoryId => integer().nullable().references(Categories, #id, onDelete: KeyAction.setNull)();
}

// If you were to delete a category:
// await (db.delete(db.categories)..where((c) => c.id.equals(5))).go();
// The `categoryId` for all todos previously linked to category 5 will now be `null`.
</code></pre>

        <h4>Foreign Key to a non-integer Primary Key</h4>
        <p>
            Foreign keys don't have to point to an <code>integer</code> ID. The <code>todos</code> table references the <code>Users</code> table's string-based primary key.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// The `Users` table has a string primary key
class Users extends Table {
  TextColumn get id => text()();
  // ... other columns
  @override
  Set&lt;Column&gt; get primaryKey => {id};
}

// The `Todos` table correctly references the string ID of the `Users` table
class Todos extends Table {
  // ... other columns
  TextColumn get userId => text().references(Users, #id)();
}
</code></pre>

        <h2 id="crud">3. CRUD Operations</h2>

        <h3 id="companion-vs-dataclass">Companion vs. Data Class: The Write/Read Distinction</h3>
        <p>
            When working with Drift, it's crucial to understand the difference between the two main types of objects generated for each table (e.g., <code>Todos</code> table):
        </p>
        
        <h4>1. The Data Class (e.g., <code>Todo</code>, <code>Category</code>)</h4>
        <p>
            The plain data class represents a <b>complete row read from the database</b>. It includes <b>all</b> columns, including auto-incremented primary keys (like <code>id</code>) and columns with default values (like <code>completed</code> or <code>createdAt</code>). You get this back when you use **<code>.get()</code>** or **<code>.watch()</code>**.
        </p>
        
        <h4>2. The Companion Class (e.g., <code>TodosCompanion</code>)</h4>
        <p>
            The Companion class represents <b>data to be written to the database</b>. There are two primary ways to construct it, depending on the operation:
        </p>
        
        <h5>Method A: Default Constructor (The **Targeted Update** method)</h5>
        <p>
            This constructor requires the use of the special wrapper, <b><code>Value&lt;T&gt;</code></b>, for every field. This is necessary because it clearly signals your intent to the database:
            <ul>
                <li><b>Explicitly Set a Value:</b> Use <code>Value('New Title')</code>.</li>
                <li><b>Explicitly Set to NULL:</b> Use <code>Value(null)</code> for nullable columns.</li>
                <li><b>Omit/Ignore:</b> Simply omit the field to let the database use its default or ignore it during an update.</li>
            </ul>
        </p>
        <p><b>Use Case:</b> When performing **targeted updates** (e.g., changing only the `completed` status of a `Todo`).</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Use this for UPDATES or when you only have partial data
await db.update(db.todos).write(
  const TodosCompanion(
    completed: Value(true), // Only update this field
    // other fields are omitted and IGNORED
  ),
);
</code></pre>
        
        <h5>Method B: Named <code>.insert()</code> Constructor (The **Convenience Insert** method)</h5>
        <p>
            The named constructor, **<code>TodosCompanion.insert(...)</code>**, is generated for tables and allows you to pass non-nullable values *directly*, without the `Value()` wrapper.
        </p>
        <p>
            <b>It only accepts fields that are required for a new row</b> (i.e., non-nullable columns without defaults), and it automatically handles auto-incremented fields (`id`) and fields with defaults (`createdAt`, `completed`) for you.
        </p>
        <p><b>Use Case:</b> When performing a **full, simple insertion** of a new row.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Use this only for INSERTS, as it's cleaner
await db.into(db.todos).insert(
  TodosCompanion.insert(
    title: 'New Task Title',      // No Value() wrapper needed!
    content: 'Full content notes', // No Value() wrapper needed!
    userId: currentUser.id,      // Required foreign key
  ),
);
</code></pre>
        <p>
            Note that **in both cases**, you must still use the fluent API: **`db.into(db.todos).insert(...)`** to tell Drift where to send the data. The Companion object is just the payload.
        </p>
        
        <p>This section covers all fundamental data manipulation operations, with explanations of when to use each method.</p>

        <h3>Create (Insert)</h3>
        <h4>Method 1: <code>insert()</code></h4>
        <p><b>When to use:</b> The standard method for creating a new, unique record.</p>
        <p><b>Why:</b> It's simple and efficient. It returns the <code>Future&lt;int&gt;</code> of the auto-incremented <code>id</code> of the new row.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Option A: Using the convenience constructor (recommended for inserts)
Future&lt;int&gt; addTodo(String title, String content, String userId) {
  return db.into(db.todos).insert(
    TodosCompanion.insert(
      title: title,
      content: content,
      uuid: Uuid().v4(), // Still a direct value
      userId: userId,
      // priority and completed fields are omitted as they use database defaults
    ),
  );
}

// Option B: Using the default constructor with Value() (more explicit)
Future&lt;int&gt; addTodoExplicit(TodosCompanion entry) {
  return db.into(db.todos).insert(entry);
}

// Example usage of the explicit method from earlier:
await addTodoExplicit(TodosCompanion(
  title: Value('Buy groceries'),
  content: Value('Milk, bread, cheese'),
  uuid: Value(Uuid().v4()),
  userId: Value(currentUser.id),
  priority: Value(Priority.high),
));
</code></pre>

        <h4>Method 2: <code>insertReturning()</code></h4>
        <p><b>When to use:</b> When you need the complete, newly created object back immediately after inserting it, including all default values (like <code>id</code> and <code>createdAt</code>).</p>
        <p><b>Why:</b> This saves you from making a second query to fetch the new item. It's perfect for immediately adding the new item to a list in your UI.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Insert a new todo using the convenience constructor and get back the full object
Future&lt;Todo&gt; addAndGetTodo(String title, String content, String userId) {
  return db.into(db.todos).insertReturning(
    TodosCompanion.insert(
      title: title,
      content: content,
      uuid: Uuid().v4(),
      userId: userId,
    )
  );
}

// Example usage: get the created item with its ID and created date
final newTodo = await addAndGetTodo(
  'Review report',
  'Review and send the quarterly report.',
  currentUser.id,
);
print('New todo ID: ${newTodo.id}, priority: ${newTodo.priority}');
</code></pre>

        <h4>Method 3: <code>insertOnConflictUpdate()</code> (Upsert)</h4>
        <p><b>When to use:</b> When synchronizing data. Insert if new, update if a record with the same primary key or unique key already exists.</p>
        <p><b>Why:</b> It handles both insert and update logic in a single, atomic database operation.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// For Upsert, we usually need the default constructor with Value() 
// because we are explicitly setting a unique key (like `uuid` or primary key) 
// to signal the conflict check.
Future&lt;void&gt; upsertTodo(TodosCompanion entry) {
  return db.into(db.todos).insertOnConflictUpdate(entry);
}

// Example: upserting a Todo based on its `uuid`.
final todoFromApi = TodosCompanion(
  title: Value('Update from API'),
  content: Value('New content for this todo'),
  uuid: Value('a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6'), // Key for conflict check
  priority: Value(Priority.high), 
);
await upsertTodo(todoFromApi); 
</code></pre>

        <h4>Method 4: <code>batch()</code> with <code>insertAll()</code></h4>
        <p><b>When to use:</b> When you need to insert a large number of records at once (e.g., more than 10-20).</p>
        <p><b>Why:</b> It's a huge performance optimization by wrapping all operations in a single transaction.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Insert multiple todos efficiently
Future&lt;void&gt; addMultipleTodos(List&lt;TodosCompanion&gt; entries) {
  return db.batch((b) {
    // These entries can be created using either TodosCompanion() or TodosCompanion.insert()
    b.insertAll(db.todos, entries); 
  });
}

// Example: Creating a list using the convenience constructor
final entries = [
  TodosCompanion.insert(title: 'T1', content: 'C1', userId: 'user1', uuid: 'u1'),
  TodosCompanion.insert(title: 'T2', content: 'C2', userId: 'user1', uuid: 'u2'),
];
await addMultipleTodos(entries);
</code></pre>

        <h3>Read (Select)</h3>
        <p>Use <code>select</code> to build your query and <code>get()</code> to execute it once. The result is always the **Data Class** (e.g., <code>Todo</code>).</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Get all todos and order them by creation date
Future&lt;List&lt;Todo&gt;&gt; getAllTodosSorted() =>
  db.select(db.todos)..orderBy([(t) => OrderingTerm.desc(t.createdAt)]).get();

// Get a single todo by its ID. Use getSingleOrNull() for robustness.
Future&lt;Todo?&gt; getTodoById(int id) =>
  (db.select(db.todos)..where((t) => t.id.equals(id))).getSingleOrNull();

// Get todos filtered by a specific enum value
Future&lt;List&lt;Todo&gt;&gt; getTodosByPriority(Priority priority) =>
  (db.select(db.todos)..where((t) => t.priority.equals(priority))).get();

// Get todos with a priority higher than a specific value (e.g., all high-priority todos)
Future&lt;List&lt;Todo&gt;&gt; getHigherPriorityTodos(Priority priority) =>
  (db.select(db.todos)..where((t) => t.priority.isBiggerThan(priority))).get();
</code></pre>

        <h3>Update</h3>
        <h4>Method 1: <code>replace()</code></h4>
        <p><b>When to use:</b> When you have a full data object and want to update every field in the database to match it. The object must have a primary key.</p>
        <p><b>Why:</b> It's simple and direct for overwriting an entire record.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Replaces the entire row for the given entry's id.
Future&lt;void&gt; updateTodo(Todo entry) => db.update(db.todos).replace(entry);

// Example: update a todo with new title, content, and priority
final updatedTodo = todo.copyWith(
  title: 'Updated title',
  content: 'Updated content',
  priority: Priority.low,
);
await updateTodo(updatedTodo);
</code></pre>

        <h4>Method 2: <code>write()</code></h4>
        <p><b>When to use:</b> The preferred method for **targeted updates**. Use the default `Companion` constructor with `Value()` wrappers here.</p>
        <p><b>Why:</b> It's efficient as it only sends the data for the columns you specify.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Mark a todo as completed and change its priority
Future&lt;int&gt; completeAndPrioritizeTodo(int id) {
  return (db.update(db.todos)..where((t) => t.id.equals(id)))
    .write(const TodosCompanion(
      completed: Value(true), // Only change this
      priority: Value(Priority.medium), // And this
    ));
}

// Update only the priority of a single todo
Future&lt;int&gt; updatePriority(int id, Priority newPriority) {
  return (db.update(db.todos)..where((t) => t.id.equals(id)))
    .write(TodosCompanion(priority: Value(newPriority)));
}
</code></pre>

        <h4>Method 3: <code>writeReturning()</code></h4>
        <p><b>When to use:</b> When you perform a targeted update and need the full, updated object(s) back immediately.</p>
        <p><b>Why:</b> It saves a second query and instantly refreshes the UI with the confirmed new data.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Mark a single todo as completed and get the updated object
Future&lt;Todo?&gt; markAsCompletedAndGet(int id) {
  return (db.update(db.todos)..where((t) => t.id.equals(id)))
    .writeReturning(const TodosCompanion(completed: Value(true)))
    .then((list) => list.isNotEmpty ? list.first : null);
}
</code></pre>

        <h3>Delete</h3>
        <h4>Method 1: <code>go()</code></h4>
        <p><b>When to use:</b> The standard method for deleting one or more rows. It's used in 99% of cases.</p>
        <p><b>Why:</b> It efficiently deletes all rows matching the <code>where</code> clause and returns a <code>Future&lt;int&gt;</code> with the count of deleted rows.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Delete a single todo by its ID
Future&lt;int&gt; deleteTodo(int id) =>
  (db.delete(db.todos)..where((t) => t.id.equals(id))).go();

// Delete all todos with a low priority
Future&lt;int&gt; deleteLowPriorityTodos() =>
  (db.delete(db.todos)..where((t) => t.priority.equals(Priority.low))).go();
</code></pre>

        <h2 id="streams">4. Understanding Streams (Reactivity)</h2>
        <p>A Drift stream watches its query and emits a new result whenever the underlying data changes, making it perfect for building real-time UIs in Flutter with <code>StreamBuilder</code>.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Watch all todos, ordered by creation date
Stream&lt;List&lt;Todo&gt;&gt; watchAllTodos() =>
  (db.select(db.todos)..orderBy([(t) => OrderingTerm.desc(t.createdAt)])).watch();

// Watch a single todo by ID. It emits a new value if the todo is updated or deleted.
Stream&lt;Todo?&gt; watchTodoById(int id) =>
  (db.select(db.todos)..where((t) => t.id.equals(id))).watchSingleOrNull();
</code></pre>

        <h3 id="advanced-streams">Advanced Stream Use Cases</h3>
        <p><b>Watching a Join</b></p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A data class to represent the joined data
class TodoWithCategory {
  final Todo todo;
  final Category? category;
  TodoWithCategory({required this.todo, this.category});
}

// Watch all todos and their associated categories.
Stream&lt;List&lt;TodoWithCategory&gt;&gt; watchAllTodosWithCategory() {
  final query = db.select(db.todos).join([
    leftOuterJoin(db.categories, db.categories.id.equalsExp(db.todos.categoryId)),
  ]);

  return query.watch().map((rows) {
    return rows.map((row) {
      return TodoWithCategory(
        todo: row.readTable(db.todos),
        category: row.readTableOrNull(db.categories),
      );
    }).toList();
  });
}
</code></pre>

        <h2 id="filtering">5. Filtering & Query Examples</h2>
        <h3>Advanced Filtering & Expressions</h3>
        <h4>Sorting & Ordering</h4>
        <p>The <code>orderBy()</code> clause allows you to sort your query results. Use <code>OrderingTerm.asc()</code> for ascending order and <code>OrderingTerm.desc()</code> for descending.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Sort todos by title in ascending alphabetical order
Future&lt;List&lt;Todo&gt;&gt; getTodosSortedByTitleAsc() =>
  (db.select(db.todos)..orderBy([(t) => OrderingTerm.asc(t.title)])).get();

// Sort by a combination of columns: priority (desc) then title (asc)
Future&lt;List&lt;Todo&gt;&gt; getTodosSortedByPriorityAndTitle() =>
  (db.select(db.todos)..orderBy([
    (t) => OrderingTerm.desc(t.priority), // High priority first
    (t) => OrderingTerm.asc(t.title),    // Then sort alphabetically by title
  ])).get();
</code></pre>
        <h4>Using Subqueries</h4>
        <p>Find all todos belonging to categories that have "Work" in their name.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
Future&lt;List&lt;Todo&gt;&gt; getWorkTodos() {
  final workCategoryIds = db.selectOnly(db.categories)
    ..addColumns([db.categories.id])
    ..where(db.categories.name.like('%Work%'));
    
  return (db.select(db.todos)
    ..where((t) => t.categoryId.isInQuery(workCategoryIds)))
    .get();
}
</code></pre>

        <h2 id="aggregation">6. Aggregation</h2>
        <p>Aggregation is the process of computing a single value from a set of data, such as a sum, count, or average. Use <code>selectOnly()</code> to perform these queries.</p>
        
        <h4>Counting records</h4>
        <p>Count the total number of todos or the number of todos that meet a specific condition.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Count the total number of todos
Future&lt;int&gt; getTotalTodoCount() async {
  final countExp = db.todos.id.count();
  final query = db.selectOnly(db.todos)..addColumns([countExp]);
  final result = await query.getSingle();
  return result.read(countExp) ?? 0;
}
</code></pre>
        <h4>Using Aggregation with <code>GROUP BY</code></h4>
        <p>This is extremely powerful for summarizing data by a category.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A data class to hold our grouped results
class UserTodoCount {
  final String userName;
  final int todoCount;
  UserTodoCount({required this.userName, required this.todoCount});
}
// ... implementation details ...
</code></pre>

        <h2 id="advanced">7. Advanced Topics</h2>
        <h3>Advanced Joins</h3>
        <p>Join with an aggregate function to count todos in each category.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
class CategoryTodoCount {
  final String categoryName;
  final int todoCount;
  CategoryTodoCount({required this.categoryName, required this.todoCount});
}
// ... implementation details ...
</code></pre>

        <h2 id="migrations">8. Comprehensive Migrations Guide</h2>
        <p>
            Database schema changes are inevitable as your app evolves. Drift's <b>migration system</b> provides a robust and version-controlled way to manage these changes.
        </p>
        
        <div class="note">
            <h4>The <b>MigrationStrategy</b></h4>
            <p>Your database class must override the <code>migration</code> getter and return a <code>MigrationStrategy</code> object. This is the central point for all your migration logic.</p>
            <pre><button class="copy-button">Copy</button><code class="language-dart">
@DriftDatabase(tables: [Todos, Categories, Users])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 5; // The current database version

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (Migrator m) {
      // Create all tables for the first time
      return m.createAll();
    },
    onUpgrade: (Migrator m, int from, int to) async {
      // This is where all your version steps go
    },
  );
}
</code></pre>
        </div>
        
        <h2 id="best-practices">9. Drift Best Practices</h2>
        <p>Follow these best practices to ensure your data layer is performant, type-safe, and maintainable as your Flutter application grows.</p>

        <h3>1. Embrace the Generated Code</h3>
        <p>Drift is built around code generation, which is your greatest ally for type safety.</p>
        <ul>
            <li><b>Always use the Type-Safe API:</b> Avoid raw SQL (<code>customSelect</code>, <code>customStatement</code>) unless absolutely necessary for complex, non-supported queries. Use the generated methods like <code>db.select(db.todos).where(...)</code>.</li>
            <li><b>Use <code>Companion</code> for Writes:</b> When inserting or updating, use the generated <code>Companion</code> classes (e.g., <code>TodosCompanion</code>). Understand the difference between the **default constructor (`Value<T>`)** for updates and the **`.insert()` named constructor** for cleaner inserts.</li>
            <li><b>Separate Queries into DAOs:</b> For larger apps, organize your read/write methods into Data Access Objects (DAOs) using the <code>@DriftAccessor()</code> annotation. This keeps your main <code>AppDatabase</code> class clean and organized by feature.</li>
        </ul>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
@DriftAccessor(tables: [Todos, Users])
class TodosDao extends DatabaseAccessor&lt;AppDatabase&gt; with _$TodosDaoMixin {
  TodosDao(AppDatabase db) : super(db);

  // All todo-related queries go here, referencing `db.todos`
  Stream&lt;List&lt;Todo&gt;&gt; watchAllTodos() => 
      select(todos).watch();
}
</code></pre>

        <h3>2. Optimize Performance with Batches and Transactions</h3>
        <p>Database I/O is often the bottleneck in applications. Minimize it by grouping operations.</p>
        <ul>
            <li><b>Batch for Bulk Operations:</b> For multiple inserts, updates, or deletes (e.g., syncing 100 records from an API), use <code>db.batch()</code> to send all commands to the database engine at once. This drastically reduces transaction overhead.</li>
            <li><b>Use Transactions for Integrity:</b> Use <code>db.transaction()</code> when you need a series of writes to succeed or fail as a single unit (e.g., moving a todo from one category to another).</li>
        </ul>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
Future&lt;void&gt; processSyncUpdates(List&lt;TodosCompanion&gt; updates) async {
  // Use a transaction for integrity, and batch for performance
  await db.transaction(() async {
    await db.batch((b) {
      b.insertAllOnConflictUpdate(db.todos, updates);
      // ... potentially other updates/inserts here
    });
    // This transaction ensures the batch completes successfully or rolls back.
  });
}
</code></pre>

        <h3>3. Think Reactively with Streams</h3>
        <p>Use Drift's built-in stream capabilities to automatically update your Flutter widgets.</p>
        <ul>
            <li><b>Prefer <code>.watch()</code> over <code>.get()</code>:</b> If you're displaying data that can change (e.g., a list of todos), use the <code>.watch()</code> method on your query and listen to it with a Flutter <code>StreamBuilder</code>. The stream automatically emits a new value whenever the data changes, even if the change happens in a different part of your app.</li>
            <li><b>Watch Joins:</b> Drift can efficiently watch queries involving joins, ensuring your complex UI elements (like a Todo with its Category name) update instantly.</li>
        </ul>

        <h3>4. Model Complex Data Relationally</h3>
        <p>As discussed, avoid type converters for data you need to query or filter on.</p>
        <ul>
            <li><b>Primitive for Queryable Fields:</b> Store fields you frequently filter by (<code>year</code>, <code>price</code>, <code>status</code>) in their own primitive columns (<code>IntColumn</code>, <code>TextColumn</code>).</li>
            <li><b>Type Converter for Non-Queryable Fields:</b> Use <code>TypeConverter</code> only for complex, nested data structures (like a list of tags or user preferences) that you retrieve and save as a whole, but <b>never</b> need to filter or sort by.</li>
        </ul>

    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const copyButtons = document.querySelectorAll('.copy-button');
            copyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const pre = button.parentElement;
                    const code = pre.querySelector('code');
                    const textToCopy = code.innerText;
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        button.innerText = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.innerText = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
                });
            });
        });
    </script>
</body>
</html>
