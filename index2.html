<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drift for Flutter Cheatsheet</title>
    <!-- Google Fonts: Inter for body, JetBrains Mono for code -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- Prism.js for syntax highlighting (Default Light Theme) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            /* Default Light Theme Palette */
            --bg-color: #ffffff;
            --surface-color: #f8f9fa;
            --border-color: #dee2e6;
            --text-color: #212529;
            
            --header-color: #0056b3;
            --accent-color: #6f42c1;
            
            --button-bg: #6c757d;
            --button-hover-bg: #5a6268;
            --button-copied-bg: #28a745;
            
            --navbar-height: 60px;
        }

        html {
            scroll-behavior: smooth;
            scroll-padding-top: calc(var(--navbar-height) + 1rem);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.7;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding-top: var(--navbar-height);
        }
        
        /* === Sticky Navbar === */
        .navbar {
            position: fixed; top: 0; left: 0; width: 100%; height: var(--navbar-height);
            background-color: var(--surface-color); border-bottom: 1px solid var(--border-color);
            z-index: 1000; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .navbar ul { display: flex; list-style: none; margin: 0; padding: 0 1rem; overflow-x: auto; }
        .navbar li a {
            display: block; padding: 0 1rem; line-height: var(--navbar-height); text-decoration: none;
            color: var(--header-color); font-weight: 700; white-space: nowrap;
            transition: background-color 0.2s, color 0.2s; border-bottom: 2px solid transparent;
        }
        .navbar li a:hover { background-color: #e9ecef; color: #000; }
        
        /* === Main Content === */
        .container { max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
        h1, h2, h3 { color: var(--header-color); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; font-weight: 700; }
        h1 { text-align: center; font-size: 2.5em; border-bottom: none; }
        h2 { margin-top: 3em; font-size: 2em; }
        h3 { margin-top: 2.5em; font-size: 1.5em; color: #007bff; border-bottom-style: dashed; }
        p, li { font-size: 1.1em; }
        
        /* === Professional Code Styling === */
        pre, code, pre *, code * {
            font-family: 'JetBrains Mono', monospace !important;
            font-variant-ligatures: none;
        }
        
        pre {
            border: 1px solid var(--border-color); border-radius: 8px;
            padding: 1.2em; overflow-x: auto; position: relative;
            line-height: 1.6; font-size: 0.9em;
            margin: 1em 0;
        }
        
        code:not(pre > code) {
            background-color: #e9ecef; color: #c7254e;
            padding: 0.2em 0.4em; border-radius: 4px; font-size: 0.85em;
        }
        
        .copy-button {
            position: absolute; top: 10px; right: 10px; background-color: var(--button-bg);
            color: #ffffff; border: none; padding: 8px 12px;
            border-radius: 5px; cursor: pointer; opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s; font-family: 'Inter', sans-serif;
        }
        
        pre:hover .copy-button { opacity: 1; }
        .copy-button:hover { background-color: var(--button-hover-bg); }
        .copy-button.copied { background-color: var(--button-copied-bg); }
        
        .note {
            background-color: #fff3cd; border-left: 4px solid #ffeeba;
            color: #664d03; padding: 1em; border-radius: 8px; margin: 1.5em 0;
        }

        /* === FIX for PrismJS Background Glitch === */
        .token.operator, .token.entity, .token.url,
        .language-css .token.string, .style .token.string {
            background: transparent;
        }
    </style>
  
</head>
<body>
    <nav class="navbar">
        <ul>
            <li><a href="#setup">Setup</a></li>
            <li><a href="#tables">Tables</a></li>
            <li><a href="#crud">CRUD</a></li>
            <li><a href="#streams">Streams</a></li>
            <li><a href="#filtering">Filtering</a></li>
            <li><a href="#aggregation">Aggregation</a></li>
            <li><a href="#advanced">Advanced</a></li>
        </ul>
    </nav>
    <div class="container">
        <h1>Drift for Flutter Cheatsheet</h1>
        <p>A comprehensive, single-file guide to Drift, the reactive persistence library for Dart & Flutter.</p>

        <h2 id="setup">1. Setup</h2>
        <p>Add the following dependencies to your <code>pubspec.yaml</code> file. The <code>drift_dev</code> and <code>build_runner</code> packages are for code generation, which is a core part of Drift.</p>
        <pre><button class="copy-button">Copy</button><code class="language-yaml">
dependencies:
  flutter:
    sdk: flutter
  drift: ^2.18.0
  sqlite3_flutter_libs: ^0.5.20
  path_provider: ^2.1.3
  path: ^1.9.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  drift_dev: ^2.18.0
  build_runner: ^2.4.9
</code></pre>

        <h2 id="tables">2. Defining Tables & Code Generation</h2>
        <p>
            Tables are defined as Dart classes that extend <code>Table</code>. You define columns as getters, and each column type has its own set of modifiers (e.g., <code>.autoIncrement()</code>, <code>.withLength()</code>, <code>.withDefault()</code>).
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
import 'package:drift/drift.dart';

// Represents a category for todos
@TableIndex(name: 'idx_category_name', columns: {#name})
class Categories extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().withLength(min: 3, max: 32).unique()();
  // We use .unique() here to ensure no two categories have the same name.
}

// Represents a user who creates todos
class Users extends Table {
  TextColumn get id => text()(); // Use a string ID for a user
  TextColumn get name => text().withLength(min: 3, max: 50)();

  @override
  Set<Column> get primaryKey => {id}; // Define a custom primary key
}

// A Dart enum for priority levels
enum Priority { low, medium, high }

class Todos extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get title => text().withLength(min: 6, max: 50)();
  TextColumn get content => text().named('body')();
  BoolColumn get completed => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  
  // A column that must be unique, not including the primary key
  TextColumn get uuid => text().unique()();
  
  // A nullable foreign key referencing the `Categories` table
  IntColumn get categoryId => integer().nullable().references(Categories, #id)();

  // A foreign key for the User who owns this todo
  TextColumn get userId => text().references(Users, #id)();
  
  // A custom column that will be stored as an integer, but handled as a Dart enum
  IntColumn get priority => intEnum<Priority>().withDefault(const Constant(0))();
}
</code></pre>
        <p>After defining your tables, run the code generator to create the necessary boilerplate:</p>
        <pre><button class="copy-button">Copy</button><code class="language-bash">
dart run build_runner build --delete-conflicting-outputs
</code></pre>

        <h3>Foreign Keys</h3>
        <p>
          Foreign keys are essential for defining <b>relationships</b> between tables and ensuring <b>data integrity</b>. They prevent you from having an item that references a non-existent entry in another table. Drift makes them type-safe and easy to use with the `.references()` syntax.
        </p>
        
        <h4>Basic Reference: `references()`</h4>
        <p>
          This is the most common use case. The `todos` table has a `categoryId` column that references the `id` column of the `categories` table. Drift ensures you cannot insert a todo with a category ID that doesn't exist.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// `Todos` table referencing `Categories`
class Todos extends Table {
  // ... other columns
  // A nullable foreign key pointing to the `Categories` table
  IntColumn get categoryId => integer().nullable().references(Categories, #id)();
}
</code></pre>
        <p>
          Here, the `#id` syntax is a Dart symbol that references the `id` column on the `Categories` table, which is a powerful way to ensure type safety. Drift will automatically generate a `categoryId` column.
        </p>

        <h4>On Delete Action: `onDelete`</h4>
        <p>
          Foreign keys can also define what happens when a referenced row is deleted. This is crucial for maintaining a clean and consistent database. The two most common actions are `cascade` and `setNull`.
        </p>
        
        <p><b>KeyAction.cascade</b> (Delete the children)</p>
        <p>
          This is the most destructive action. When you delete a row from the parent table, <b>all rows in the child table that reference it will also be deleted automatically</b>. This is useful for strong, hierarchical relationships, like an album and its photos.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A `Photos` table that is strongly linked to an `Albums` table
class Albums extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
}

class Photos extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get url => text()();
  // If an album is deleted, all photos in that album will also be deleted.
  IntColumn get albumId => integer().references(Albums, #id, onDelete: KeyAction.cascade)();
}

// In your DAO, if you were to delete an album:
// await (db.delete(db.albums)..where((a) => a.id.equals(1))).go();
// This will automatically delete all photos where `albumId` is 1.
</code></pre>

        <p><b>KeyAction.setNull</b> (Unlink the children)</p>
        <p>
          This action is less destructive. When you delete a parent row, the foreign key column in all child rows that reference it is simply <b>set to `null`</b>. This is perfect for the `todos` and `categories` relationship, where a todo can exist without a category.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A `Todos` table referencing `Categories` with `setNull`
class Todos extends Table {
  // ... other columns
  // When a category is deleted, the `categoryId` on its todos is set to null.
  IntColumn get categoryId => integer().nullable().references(Categories, #id, onDelete: KeyAction.setNull)();
}

// If you were to delete a category:
// await (db.delete(db.categories)..where((c) => c.id.equals(5))).go();
// The `categoryId` for all todos previously linked to category 5 will now be `null`.
</code></pre>

        <h4>Foreign Key to a non-integer Primary Key</h4>
        <p>
          Foreign keys don't have to point to an `integer` ID. The `todos` table references the `Users` table's string-based primary key.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// The `Users` table has a string primary key
class Users extends Table {
  TextColumn get id => text()();
  // ... other columns
  @override
  Set<Column> get primaryKey => {id};
}

// The `Todos` table correctly references the string ID of the `Users` table
class Todos extends Table {
  // ... other columns
  TextColumn get userId => text().references(Users, #id)();
}
</code></pre>

        <h2 id="crud">3. CRUD Operations</h2>
        <p>This section covers all fundamental data manipulation operations, with explanations of when to use each method.</p>

        <h3>Create (Insert)</h3>
        <h4>Method 1: <code>insert()</code></h4>
        <p><b>When to use:</b> The standard method for creating a new, unique record. It's the most common insert operation.</p>
        <p><b>Why:</b> It's simple and efficient. It returns the <code>Future&lt;int&gt;</code> of the auto-incremented <code>id</code> of the new row, which is often all you need.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Insert a new todo and get back its generated ID
Future<int> addTodo(TodosCompanion entry) {
  return db.into(db.todos).insert(entry);
}

// Example usage:
await addTodo(TodosCompanion(
  title: Value('Buy groceries'),
  content: Value('Milk, bread, cheese'),
  uuid: Value(Uuid().v4()),
  userId: Value(currentUser.id),
  // Inserting an enum value directly
  priority: Value(Priority.high),
));
</code></pre>

        <h4>Method 2: <code>insertReturning()</code></h4>
        <p><b>When to use:</b> When you need the complete, newly created object back immediately after inserting it, including all default values (like <code>id</code> and <code>createdAt</code>).</p>
        <p><b>Why:</b> This saves you from making a second query to fetch the new item. It's perfect for immediately adding the new item to a list in your UI.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Insert a new todo and get back the full object
Future<Todo> addAndGetTodo(TodosCompanion entry) {
  return db.into(db.todos).insertReturning(entry);
}

// Example usage: get the created item with its ID and created date
final newTodo = await addAndGetTodo(TodosCompanion(
  title: Value('Review report'),
  content: Value('Review and send the quarterly report.'),
  uuid: Value(Uuid().v4()),
  userId: Value(currentUser.id),
  priority: Value(Priority.medium),
));
print('New todo ID: ${newTodo.id}, priority: ${newTodo.priority}');
</code></pre>

        <h4>Method 3: <code>insertOnConflictUpdate()</code> (Upsert)</h4>
        <p><b>When to use:</b> When synchronizing data, for example from a remote API. You want to insert a record if it's new, but update it if a record with the same primary key or unique key already exists.</p>
        <p><b>Why:</b> It elegantly handles both insert and update logic in a single, atomic database operation, preventing "UNIQUE constraint failed" errors and simplifying your sync code.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Note: We can pass either a full data class or a Companion.
// If a Todo with the same UUID or primary key exists, it will be updated. Otherwise, it's inserted.
Future<void> upsertTodo(TodosCompanion entry) {
  return db.into(db.todos).insertOnConflictUpdate(entry);
}

// Example for upserting a Todo based on its `uuid`.
final todoFromApi = TodosCompanion(
  title: Value('Update from API'),
  content: Value('New content for this todo'),
  uuid: Value('a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6'),
  priority: Value(Priority.high), // Can also upsert the priority
);
await upsertTodo(todoFromApi); // If a todo with this uuid exists, it's updated. Otherwise, it's inserted.
</code></pre>

        <h4>Method 4: <code>batch()</code> with <code>insertAll()</code></h4>
        <p><b>When to use:</b> When you need to insert a large number of records at once (e.g., more than 10-20).</p>
        <p><b>Why:</b> It's a huge performance optimization. A batch wraps all operations in a single transaction, which is significantly faster than performing many individual <code>insert</code> calls, each in its own transaction.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Insert multiple todos efficiently
Future<void> addMultipleTodos(List<TodosCompanion> entries) {
  return db.batch((b) {
    b.insertAll(db.todos, entries);
    // You can add other operations here, like inserting into another table
    // b.insertAll(db.categories, someCategories);
  });
}

// Example: Inserting a list of todos from a JSON response
final todosFromApi = jsonList.map((json) => TodosCompanion.fromJson(json)).toList();
await addMultipleTodos(todosFromApi);
</code></pre>

        <h3>Read (Select)</h3>
        <p>Use <code>select</code> to build your query and <code>get()</code> to execute it once.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Get all todos and order them by creation date
Future<List<Todo>> getAllTodosSorted() =>
  db.select(db.todos)..orderBy([(t) => OrderingTerm.desc(t.createdAt)]).get();

// Get a single todo by its ID. Use getSingleOrNull() for robustness.
Future<Todo?> getTodoById(int id) =>
  (db.select(db.todos)..where((t) => t.id.equals(id))).getSingleOrNull();

// Get todos filtered by a specific enum value
Future<List<Todo>> getTodosByPriority(Priority priority) =>
  (db.select(db.todos)..where((t) => t.priority.equals(priority))).get();

// Get todos with a priority higher than a specific value (e.g., all high-priority todos)
Future<List<Todo>> getHigherPriorityTodos(Priority priority) =>
  (db.select(db.todos)..where((t) => t.priority.isBiggerThan(priority))).get();
</code></pre>

        <h3>Update</h3>
        <h4>Method 1: <code>replace()</code></h4>
        <p><b>When to use:</b> When you have a full data object and want to update every field in the database to match it. The object must have a primary key.</p>
        <p><b>Why:</b> It's simple and direct for overwriting an entire record. However, it can be less efficient if you only need to change one or two fields.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Replaces the entire row for the given entry's id.
Future<void> updateTodo(Todo entry) => db.update(db.todos).replace(entry);

// Example: update a todo with new title, content, and priority
final updatedTodo = todo.copyWith(
  title: 'Updated title',
  content: 'Updated content',
  priority: Priority.low,
);
await updateTodo(updatedTodo);
</code></pre>

        <h4>Method 2: <code>write()</code></h4>
        <p><b>When to use:</b> The preferred method for targeted updates. Use this when you only want to change specific columns.</p>
        <p><b>Why:</b> It's more efficient as it only sends the data for the columns you specify in the <code>TodosCompanion</code>. Use <code>Value(someValue)</code> to explicitly set a field.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Mark a todo as completed and change its priority
Future<int> completeAndPrioritizeTodo(int id) {
  return (db.update(db.todos)..where((t) => t.id.equals(id)))
    .write(const TodosCompanion(
      completed: Value(true),
      priority: Value(Priority.medium),
    ));
}

// Update only the priority of a single todo
Future<int> updatePriority(int id, Priority newPriority) {
  return (db.update(db.todos)..where((t) => t.id.equals(id)))
    .write(TodosCompanion(priority: Value(newPriority)));
}
</code></pre>

        <h4>Method 3: <code>writeReturning()</code></h4>
        <p><b>When to use:</b> When you perform a targeted update and need the full, updated object(s) back immediately.</p>
        <p><b>Why:</b> Just like <code>insertReturning</code>, it saves a second query. It's perfect for updating an item in a list and instantly refreshing the UI with the confirmed new data.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Mark a single todo as completed and get the updated object
Future<Todo?> markAsCompletedAndGet(int id) {
  return (db.update(db.todos)..where((t) => t.id.equals(id)))
    .writeReturning(const TodosCompanion(completed: Value(true)))
    .then((list) => list.isNotEmpty ? list.first : null);
}
</code></pre>

        <h3>Delete</h3>
        <h4>Method 1: <code>go()</code></h4>
        <p><b>When to use:</b> The standard method for deleting one or more rows. It's used in 99% of cases.</p>
        <p><b>Why:</b> It efficiently deletes all rows matching the <code>where</code> clause and returns a <code>Future&lt;int&gt;</code> with the count of deleted rows.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Delete a single todo by its ID
Future<int> deleteTodo(int id) =>
  (db.delete(db.todos)..where((t) => t.id.equals(id))).go();

// Delete all todos with a low priority
Future<int> deleteLowPriorityTodos() =>
  (db.delete(db.todos)..where((t) => t.priority.equals(Priority.low))).go();
</code></pre>

        <h2 id="streams">4. Understanding Streams (Reactivity)</h2>
        <p>A Drift stream watches its query and emits a new result whenever the underlying data changes, making it perfect for building real-time UIs in Flutter with <code>StreamBuilder</code>.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Watch all todos, ordered by creation date
Stream<List<Todo>> watchAllTodos() =>
  (db.select(db.todos)..orderBy([(t) => OrderingTerm.desc(t.createdAt)])).watch();

// Watch a single todo by ID. It emits a new value if the todo is updated or deleted.
Stream<Todo?> watchTodoById(int id) =>
  (db.select(db.todos)..where((t) => t.id.equals(id))).watchSingleOrNull();

// Watch only the high-priority todos
Stream<List<Todo>> watchHighPriorityTodos() =>
  (db.select(db.todos)..where((t) => t.priority.equals(Priority.high))).watch();

// Watch the count of all todos and emit a new number whenever a todo is added or deleted
Stream<int> watchTotalTodoCount() {
  final countExp = db.todos.id.count();
  final query = db.selectOnly(db.todos)..addColumns([countExp]);
  return query.map((row) => row.read(countExp) ?? 0).watchSingle();
}
</code></pre>

        <h3 id="advanced-streams">Advanced Stream Use Cases</h3>

        <h4>Watching a Dynamic Filter (Search)</h4>
        <p><b>When to use:</b> For real-time search or filtering.</p>
        <p><b>Why:</b> The `watch()` method is smart enough to listen to changes on the `todos` table. When a new todo is added or an existing one is updated, the stream will check if the new data matches the filter and emit a new list if necessary.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Watch todos that contain a search term in their title or content.
Stream<List<Todo>> watchTodosWithSearchTerm(String searchTerm) {
  return (db.select(db.todos)
    ..where((t) => t.title.like('%$searchTerm%') | t.content.like('%$searchTerm%'))
    ..orderBy([(t) => OrderingTerm.desc(t.createdAt)])
  ).watch();
}

// Example usage in a Flutter app:
// StreamBuilder<List<Todo>>(
//   stream: watchTodosWithSearchTerm(mySearchController.text),
//   builder: (context, snapshot) {
//     // ... build your list view here
//   },
// )
</code></pre>

        <h4>Watching a Join</h4>
        <p><b>When to use:</b> When your UI needs to display data from multiple related tables and react to changes in any of them. For example, a list of todos with their associated category names.</p>
        <p><b>Why:</b> The stream automatically rebuilds the list whenever a todo is added/updated/deleted or a category is added/updated/deleted. This ensures your UI is always up-to-date with the complex, joined data.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A data class to represent the joined data
class TodoWithCategory {
  final Todo todo;
  final Category? category;
  TodoWithCategory({required this.todo, this.category});
}

// Watch all todos and their associated categories.
Stream<List<TodoWithCategory>> watchAllTodosWithCategory() {
  final query = db.select(db.todos).join([
    leftOuterJoin(db.categories, db.categories.id.equalsExp(db.todos.categoryId)),
  ]);

  return query.watch().map((rows) {
    return rows.map((row) {
      return TodoWithCategory(
        todo: row.readTable(db.todos),
        category: row.readTableOrNull(db.categories),
      );
    }).toList();
  });
}
</code></pre>

        <h4>Watching a Grouped Aggregate</h4>
        <p><b>When to use:</b> To display summary data that needs to be updated in real-time. A common use case is a dashboard or a sidebar that shows statistics.</p>
        <p><b>Why:</b> This stream will emit a new list of counts whenever a todo is added, deleted, or its category is changed. You can show a live count of todos for each category without needing to manually refresh the data.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A data class to hold our grouped results
class CategoryTodoCount {
  final String categoryName;
  final int todoCount;
  CategoryTodoCount({required this.categoryName, required this.todoCount});
}

// Watch the number of todos per category.
Stream<List<CategoryTodoCount>> watchCategoryTodoCounts() {
  final todoCount = db.todos.id.count();
  final query = db.select(db.categories).join([
    leftOuterJoin(db.todos, db.todos.categoryId.equalsExp(db.categories.id)),
  ])
  ..addColumns([todoCount])
  ..groupBy([db.categories.id]);

  return query.watch().map((rows) {
    return rows.map((row) => CategoryTodoCount(
      categoryName: row.readTable(db.categories).name,
      todoCount: row.read(todoCount) ?? 0,
    )).toList();
  });
}
</code></pre>

        <h2 id="filtering">5. Filtering & Query Examples</h2>
        <h3>Advanced Filtering & Expressions</h3>
        <h4>Sorting & Ordering</h4>
        <p>The <code>orderBy()</code> clause allows you to sort your query results. Use <code>OrderingTerm.asc()</code> for ascending order and <code>OrderingTerm.desc()</code> for descending.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Sort todos by title in ascending alphabetical order
Future<List<Todo>> getTodosSortedByTitleAsc() =>
  (db.select(db.todos)..orderBy([(t) => OrderingTerm.asc(t.title)])).get();

// Sort todos by creation date in descending order (newest first)
Future<List<Todo>> getTodosSortedByDateDesc() =>
  (db.select(db.todos)..orderBy([(t) => OrderingTerm.desc(t.createdAt)])).get();

// Sort by an enum value. Since `Priority` is mapped to an int (low=0, medium=1, high=2),
// this sorts them in the correct logical order.
Future<List<Todo>> getTodosSortedByPriority() =>
  (db.select(db.todos)..orderBy([(t) => OrderingTerm.asc(t.priority)])).get();

// Sort by a combination of columns: priority (desc) then title (asc)
Future<List<Todo>> getTodosSortedByPriorityAndTitle() =>
  (db.select(db.todos)..orderBy([
    (t) => OrderingTerm.desc(t.priority), // High priority first
    (t) => OrderingTerm.asc(t.title),    // Then sort alphabetically by title
  ])).get();
</code></pre>
        <h4>Using Subqueries</h4>
        <p>Find all todos belonging to categories that have "Work" in their name. This is a powerful way to join data without a direct <code>join</code> operation.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
Future<List<Todo>> getWorkTodos() {
  final workCategoryIds = db.selectOnly(db.categories)
    ..addColumns([db.categories.id])
    ..where(db.categories.name.like('%Work%'));
    
  return (db.select(db.todos)
    ..where((t) => t.categoryId.isInQuery(workCategoryIds)))
    .get();
}

// Find all users who have at least one completed todo
Future<List<User>> getUsersWithCompletedTodos() {
  final usersWithCompleted = db.selectOnly(db.todos)
    ..addColumns([db.todos.userId])
    ..where(db.todos.completed.equals(true));
  
  return (db.select(db.users)
    ..where((u) => u.id.isInQuery(usersWithCompleted)))
    .get();
}
</code></pre>
        <h4>Using Custom Expressions</h4>
        <p>Find all todos created on a Monday using SQLite's <code>strftime</code> function. This is how you access raw SQL functions.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
Future<List<Todo>> getMondayTodos() {
  // SQLite: strftime('%w', date) returns '1' for Monday
  final weekday = CustomExpression<String>("strftime('%w', created_at)");
  return (db.select(db.todos)..where((_) => weekday.equals('1'))).get();
}

// Find all todos whose title starts with 'Buy' (case-insensitive)
Future<List<Todo>> getTodosStartingWithBuy() {
  // Use a custom expression to convert the title to lowercase for comparison
  final lowerTitle = CustomExpression<String>("LOWER(title)");
  return (db.select(db.todos)..where((_) => lowerTitle.like('buy%'))).get();
}
</code></pre>

        <h2 id="aggregation">6. Aggregation</h2>
        <p>Aggregation is the process of computing a single value from a set of data, such as a sum, count, or average. Use <code>selectOnly()</code> to perform these queries.</p>
        
        <h4>Counting records</h4>
        <p>Count the total number of todos or the number of todos that meet a specific condition.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Count the total number of todos
Future<int> getTotalTodoCount() async {
  final countExp = db.todos.id.count();
  final query = db.selectOnly(db.todos)..addColumns([countExp]);
  final result = await query.getSingle();
  return result.read(countExp) ?? 0;
}

// Count how many todos are completed
Future<int> getCompletedTodoCount() async {
  final completedCount = db.todos.completed.count(filter: db.todos.completed.equals(true));
  final query = db.selectOnly(db.todos)..addColumns([completedCount]);
  final result = await query.getSingle();
  return result.read(completedCount) ?? 0;
}
</code></pre>
        <h4>Calculating Sums and Averages</h4>
        <p>Compute the sum or average of a numeric column. Useful for things like expense tracking.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Assuming a new `Task` table with a `duration` column
class Tasks extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get durationInMinutes => integer()();
}

// Calculate the total duration of all tasks
Future<int> getTotalTaskDuration() async {
  final totalDuration = db.tasks.durationInMinutes.sum();
  final query = db.selectOnly(db.tasks)..addColumns([totalDuration]);
  final result = await query.getSingle();
  return result.read(totalDuration) ?? 0;
}

// Calculate the average duration of completed tasks
Future<double> getAverageCompletedTaskDuration() async {
  final averageDuration = db.tasks.durationInMinutes.avg();
  final query = db.selectOnly(db.tasks)
    ..addColumns([averageDuration])
    ..where(db.tasks.completed.equals(true));
  final result = await query.getSingle();
  return result.read(averageDuration) ?? 0.0;
}
</code></pre>
        <h4>Finding Minimum and Maximum Values</h4>
        <p>Find the earliest or latest date, or the lowest or highest value in a column.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Find the creation date of the oldest todo
Future<DateTime?> getOldestTodoDate() async {
  final oldestDate = db.todos.createdAt.min();
  final query = db.selectOnly(db.todos)..addColumns([oldestDate]);
  final result = await query.getSingleOrNull();
  return result?.read(oldestDate);
}

// Find the title of the todo with the highest priority
Future<String?> getTitleOfHighestPriorityTodo() async {
  final maxPriority = db.todos.priority.max();
  final query = db.selectOnly(db.todos)
    ..addColumns([db.todos.title, maxPriority])
    ..orderBy([OrderingTerm.desc(maxPriority)])
    ..limit(1);
  final result = await query.getSingleOrNull();
  return result?.read(db.todos.title);
}
</code></pre>

        <h4>Using Aggregation with <code>GROUP BY</code></h4>
        <p>This is extremely powerful for summarizing data by a category. For example, counting todos for each user or category.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// A data class to hold our grouped results
class UserTodoCount {
  final String userName;
  final int todoCount;
  UserTodoCount({required this.userName, required this.todoCount});
}

Future<List<UserTodoCount>> getTodosPerUser() async {
  final todoCount = db.todos.id.count();
  final query = db.select(db.users).join([
    innerJoin(db.todos, db.todos.userId.equalsExp(db.users.id)),
  ])
  ..addColumns([db.users.name, todoCount])
  ..groupBy([db.users.id]);

  final results = await query.get();
  return results.map((row) => UserTodoCount(
    userName: row.readTable(db.users).name,
    todoCount: row.read(todoCount) ?? 0,
  )).toList();
}
</code></pre>

        <h2 id="advanced">7. Advanced Topics</h2>
        <h3>Advanced Joins</h3>
        <p>Join with an aggregate function to count todos in each category.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
class CategoryTodoCount {
  final String categoryName;
  final int todoCount;
  CategoryTodoCount({required this.categoryName, required this.todoCount});
}

Future<List<CategoryTodoCount>> getCategoryTodoCounts() {
  final todoCount = db.todos.id.count();
  final query = db.select(db.categories).join([
    innerJoin(db.todos, db.todos.categoryId.equalsExp(db.categories.id))
  ]);
  query..addColumns([todoCount])..groupBy([db.categories.id]);
  return query.map((row) => CategoryTodoCount(
    categoryName: row.readTable(db.categories).name,
    todoCount: row.read(todoCount) ?? 0,
  )).get();
}
</code></pre>

        <h3>Advanced DAOs</h3>
        <p>DAOs (Data Access Objects) can abstract complex joins or transactions into simple, reusable methods. This makes your database logic more modular and testable.</p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
@DriftAccessor(tables: [Todos, Categories, Users])
class AdvancedDao extends DatabaseAccessor<AppDatabase> with _$AdvancedDaoMixin {
  AdvancedDao(AppDatabase db) : super(db);

  // A data class for a complex join result
  // You must define this class yourself
  class FullTodo {
    final Todo todo;
    final Category? category;
    final User user;
    FullTodo({required this.todo, required this.category, required this.user});
  }

  // Abstract a complex 3-table join into a clean API
  Stream<List<FullTodo>> watchFullTodos() {
    final query = select(todos).join([
      innerJoin(users, todos.userId.equalsExp(users.id)),
      leftOuterJoin(categories, todos.categoryId.equalsExp(categories.id)),
    ]);
    return query.watch().map((rows) {
      return rows.map((row) {
        return FullTodo(
          todo: row.readTable(todos),
          user: row.readTable(users),
          category: row.readTableOrNull(categories),
        );
      }).toList();
    });
  }

  // Encapsulate business logic in a transaction
  Future<void> completeTodoAndAwardPoints(int todoId, int userId) {
    return transaction(() async {
      await (update(todos)..where((t) => t.id.equals(todoId)))
          .write(const TodosCompanion(completed: Value(true)));
      
      // Award 10 points to the user. You'd need a `points` column in the `Users` table.
      await (update(users)..where((u) => u.id.equals(userId)))
          .write(const UsersCompanion(points: Value.absent())); // Example placeholder for a field that's not `Value.absent()`
    });
  }
}
</code></pre>

        <h2>8. Comprehensive Migrations Guide</h2>
        <p>
            Database schema changes are inevitable as your app evolves. Drift's **migration system** provides a robust and version-controlled way to manage these changes. The core idea is that you provide a series of "migration steps" that get executed only when a user's database version is older than your app's code version.
        </p>
        
        <div class="note">
            <h4>The `MigrationStrategy`</h4>
            <p>Your database class must override the `migration` getter and return a `MigrationStrategy` object. This is the central point for all your migration logic.</p>
            <pre><button class="copy-button">Copy</button><code class="language-dart">
@DriftDatabase(tables: [Posts, Comments, Tags, PostTags])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 5; // The current database version

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (Migrator m) {
      // Create all tables for the first time
      return m.createAll();
    },
    onUpgrade: (Migrator m, int from, int to) async {
      // This is where all your version steps go
      // Example: await migrateFromVersion1(m, from, to);
    },
    // Optional: add onDowngrade for development only
  );
}
</code></pre>
        </div>
        
        <p>Let's use a real-world example: a blog app. We'll start with a basic schema and evolve it over time, showing you how to handle different scenarios.</p>

        <h3>Version 1 → 2: Adding a New Column</h3>
        <p>
            We start with a simple `Posts` table. Now, we want to add a `subtitle` column. This is the most common and straightforward migration.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// Initial V1 table schema
class Posts extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get title => text()();
  TextColumn get content => text()();
  DateTimeColumn get createdAt => dateTime()();
}

// In your `onUpgrade` method, check the version
if (from < 2) {
  // Simply add the new column. Drift handles the SQL for you.
  await m.addColumn(db.posts, db.posts.subtitle);
}
</code></pre>
        
        <h3>Version 2 → 3: Adding a Non-Nullable Column with a Default Value</h3>
        <p>
            Next, our blog needs to track the author of each post. The `author` column is non-nullable, so existing rows need a default value.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
class Posts extends Table {
  // ... existing columns
  TextColumn get author => text().withLength(min: 3).withDefault(const Constant('Anonymous'))();
}

// In your `onUpgrade` method
if (from < 3) {
  // Drift recognizes the `withDefault()` and handles the backfilling of old rows automatically.
  await m.addColumn(db.posts, db.posts.author);
}
</code></pre>

        <h3>Version 3 → 4: Adding a New Table and a Foreign Key</h3>
        <p>
            Our blog needs to support comments. We'll add a new `Comments` table and link it back to `Posts` with a foreign key.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
class Comments extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get text => text().withLength(min: 1)();
  DateTimeColumn get createdAt => dateTime()();
  // Foreign key linking to the `Posts` table
  IntColumn get postId => integer().references(Posts, #id, onDelete: KeyAction.cascade)();
}

// In your `onUpgrade` method
if (from < 4) {
  // Use `createTable` to add the new table
  await m.createTable(db.comments);
  // No need to add the foreign key column separately, `createTable` handles it.
}
</code></pre>

        <h3>Version 4 → 5: Renaming a Column</h3>
        <p>
            We've decided to change the `author` column to `userName` to be more descriptive.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// The new schema
class Posts extends Table {
  // ... existing columns
  TextColumn get userName => text().named('author').withLength(min: 3).withDefault(const Constant('Anonymous'))();
}

// In your `onUpgrade` method
if (from < 5) {
  // Use `renameColumn` for a safe, atomic operation
  await m.renameColumn(db.posts, 'author', db.posts.userName);
}
</code></pre>
        
        <h3>Version 5 → 6: Adding a Unique Constraint</h3>
        <p>
            We want to prevent duplicate post titles. This is a complex migration because SQLite doesn't let you add a unique constraint to an existing column. The solution is to recreate the table with the new constraint, copy the data, then drop the old one. Drift's `TableMigration` object simplifies this process.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
// The new schema with a `unique()` modifier
class Posts extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get title => text().unique()();
  // ... other columns
}

// In your `onUpgrade` method
if (from < 6) {
  // This recreates the entire `posts` table with the new schema,
  // copying all existing data over.
  await m.alterTable(TableMigration(db.posts));
}
</code></pre>
        
        <h3>Version 6 → 7: Adding Multiple Tables and a Many-to-Many Relationship</h3>
        <p>
            We want to add a tagging system to our blog. This requires two new tables: `Tags` and a join table `PostTags` for the many-to-many relationship.
        </p>
        <pre><button class="copy-button">Copy</button><code class="language-dart">
class Tags extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().unique()();
}

class PostTags extends Table {
  IntColumn get postId => integer().references(Posts, #id)();
  IntColumn get tagId => integer().references(Tags, #id)();
  @override
  Set<Column> get primaryKey => {postId, tagId};
}

// In your `onUpgrade` method
if (from < 7) {
  // You must create new tables in the correct order to respect foreign key constraints.
  await m.createTable(db.tags);
  await m.createTable(db.postTags);
}
</code></pre>

        <div class="note">
            <h4>Common Migration Pitfalls</h4>
            <ul>
                <li><b>Order Matters:</b> Always create tables and add columns with foreign key constraints in the correct order. The referenced table must exist first.</li>
                <li><b>`onDowngrade`:</b> Only use this for development. Drift's migrations are designed to be forward-only. Never rely on downgrades for production applications.</li>
                <li><b>Recreating Tables:</b> Be careful with `TableMigration`. It is a powerful tool but should be used for scenarios like adding a unique constraint or changing a column type, as it effectively recreates the entire table.</li>
            </ul>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const copyButtons = document.querySelectorAll('.copy-button');
            copyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const pre = button.parentElement;
                    const code = pre.querySelector('code');
                    const textToCopy = code.innerText;
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        button.innerText = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.innerText = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
                });
            });
        });
    </script>
</body>
</html>
